name: Process Project Submission

on:
  issues:
    types: [labeled]

jobs:
  process-submission:
    if: github.event.label.name == 'submission' && !contains(github.event.issue.labels.*.name, 'pr-created')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse submission and create PR
        uses: actions/github-script@v7
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_AUTHOR: ${{ github.event.issue.user.login }}
        with:
          script: |
            const fs = require('fs');

            const issueBody = process.env.ISSUE_BODY;
            const issueNumber = parseInt(process.env.ISSUE_NUMBER, 10);
            const issueTitle = process.env.ISSUE_TITLE;
            const issueAuthor = process.env.ISSUE_AUTHOR;

            try {
              // Extract JSON from the issue body
              // The JSON is in a code block after "### Project Data"
              const jsonMatch = issueBody.match(/### Project Data\s*\n```json\s*\n([\s\S]*?)\n```/);
              if (!jsonMatch) {
                throw new Error('Could not find Project Data JSON in issue body');
              }

              const project = JSON.parse(jsonMatch[1]);

              // Validate required fields
              if (!project.name || !project.github || !project.tagline) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `‚ùå **Missing required fields**\n\nPlease ensure your JSON includes:\n- name\n- tagline\n- github`
                });
                return;
              }

              // Generate ID from name
              const id = project.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
              project.id = id;

              // Remove empty optional fields
              for (const key of ['docs', 'pypi', 'condaForge', 'homepage', 'example']) {
                if (!project[key]) delete project[key];
              }

              // Check for logo upload
              const logoMatch = issueBody.match(/### Logo \(optional\)\s*\n\s*([\s\S]*?)(?=\n###|$)/);
              let logoUrl = null;
              if (logoMatch) {
                const logoContent = logoMatch[1].trim();
                // Check for uploaded image (GitHub attachment URL)
                const imgMatch = logoContent.match(/!\[.*?\]\((https:\/\/[^)]+)\)|^(https:\/\/\S+)/);
                if (imgMatch) {
                  logoUrl = imgMatch[1] || imgMatch[2];
                }
              }

              // Load existing projects
              const projectsPath = 'static/data/projects.json';
              const projects = JSON.parse(fs.readFileSync(projectsPath, 'utf-8'));

              if (projects.some(p => p.id === id)) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `‚ö†Ô∏è **Project already exists**\n\nA project with ID \`${id}\` is already in the catalog.`
                });
                return;
              }

              // Create branch
              const branchName = `submission/${id}-${issueNumber}`;
              const { data: ref } = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/main'
              });

              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: ref.object.sha
                });
              } catch (e) {
                if (e.status !== 422) throw e;
              }

              // Handle logo
              let logoPath = null;
              if (logoUrl) {
                const ext = logoUrl.match(/\.(png|svg|jpg|jpeg|webp)(\?|$)/i)?.[1] || 'png';
                logoPath = `/logos/${id}.${ext.toLowerCase()}`;
                project.logo = logoPath;

                try {
                  const response = await fetch(logoUrl);
                  if (response.ok) {
                    const buffer = await response.arrayBuffer();
                    await github.rest.repos.createOrUpdateFileContents({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      path: `static${logoPath}`,
                      message: `Add logo for ${project.name}`,
                      content: Buffer.from(buffer).toString('base64'),
                      branch: branchName
                    });
                  }
                } catch (e) {
                  console.log(`Failed to download logo: ${e.message}`);
                  delete project.logo;
                }
              }

              // Add project and update file
              projects.unshift(project);
              const projectsContent = JSON.stringify(projects, null, '\t') + '\n';

              const { data: projectsFile } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: projectsPath,
                ref: branchName
              });

              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: projectsPath,
                message: `Add ${project.name} to projects`,
                content: Buffer.from(projectsContent).toString('base64'),
                sha: projectsFile.sha,
                branch: branchName
              });

              // Create PR
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Add ${project.name} to PySimHub`,
                head: branchName,
                base: 'main',
                body: `## New Project: ${project.name}\n\nSubmitted by @${issueAuthor} in #${issueNumber}\n\n**Tagline:** ${project.tagline}\n**Tags:** ${project.tags.join(', ')}\n**Repository:** ${project.github}\n\n---\n\nü§ñ Auto-generated from issue #${issueNumber}`
              });

              // Comment on issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `üéâ **Thanks for your submission!**\n\nPR created: ${pr.html_url}\n\nA maintainer will review it shortly.`
              });

              // Add label and update title
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: ['pr-created']
              });

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                title: `[Submission] ${project.name}`
              });

              console.log(`Created PR #${pr.number} for ${project.name}`);

            } catch (error) {
              console.error('Error:', error);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `‚ùå **Error processing submission**\n\n\`\`\`\n${error.message}\n\`\`\`\n\nPlease check your JSON format and try again.`
              });
            }
