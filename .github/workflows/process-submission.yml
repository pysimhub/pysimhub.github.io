name: Process Project Submission

on:
  issues:
    types: [labeled]

jobs:
  process-submission:
    if: github.event.label.name == 'submission' && !contains(github.event.issue.labels.*.name, 'pr-created')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse submission and create PR
        uses: actions/github-script@v7
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_AUTHOR: ${{ github.event.issue.user.login }}
        with:
          script: |
            const fs = require('fs');

            const issueBody = process.env.ISSUE_BODY;
            const issueNumber = parseInt(process.env.ISSUE_NUMBER, 10);
            const issueTitle = process.env.ISSUE_TITLE;
            const issueAuthor = process.env.ISSUE_AUTHOR;

            try {
              // Extract JSON from the issue body
              // The JSON is in a code block after "### Project Data"
              const jsonMatch = issueBody.match(/### Project Data\s*\n```json\s*\n([\s\S]*?)\n```/);
              if (!jsonMatch) {
                throw new Error('Could not find Project Data JSON in issue body');
              }

              // Clean up JSON (remove trailing commas which are common user errors)
              let jsonStr = jsonMatch[1]
                .replace(/,\s*}/g, '}')
                .replace(/,\s*]/g, ']');

              let project;
              try {
                project = JSON.parse(jsonStr);
              } catch (parseError) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `‚ùå **Invalid JSON**\n\n\`\`\`\n${parseError.message}\n\`\`\`\n\nPlease check your JSON syntax and try again.`
                });
                return;
              }

              // Validate required fields
              if (!project.name || !project.github || !project.tagline) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `‚ùå **Missing required fields**\n\nPlease ensure your JSON includes:\n- name\n- tagline\n- github`
                });
                return;
              }

              // URL validation helper
              function isValidUrl(string) {
                try {
                  const url = new URL(string);
                  return url.protocol === 'http:' || url.protocol === 'https:';
                } catch {
                  return false;
                }
              }

              // Validate URLs
              const urlFields = ['github', 'docs', 'pypi', 'condaForge', 'homepage', 'example'];
              const invalidUrls = [];
              for (const field of urlFields) {
                if (project[field] && !isValidUrl(project[field])) {
                  invalidUrls.push(`- \`${field}\`: ${project[field]}`);
                }
              }

              if (invalidUrls.length > 0) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `‚ùå **Invalid URLs**\n\nThe following URLs are not valid:\n${invalidUrls.join('\n')}\n\nPlease fix and resubmit.`
                });
                return;
              }

              // Generate ID from name
              const id = project.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
              project.id = id;

              // Remove empty optional fields
              for (const key of ['docs', 'pypi', 'condaForge', 'homepage', 'example']) {
                if (!project[key]) delete project[key];
              }

              // Check for logo upload
              const logoMatch = issueBody.match(/### Logo \(optional\)\s*\n\s*([\s\S]*?)(?=\n###|$)/);
              let logoUrl = null;
              if (logoMatch) {
                const logoContent = logoMatch[1].trim();
                // Skip if empty or "No response"
                if (logoContent && logoContent !== '_No response_') {
                  // Check for markdown image: ![alt](url)
                  const mdMatch = logoContent.match(/!\[.*?\]\((https?:\/\/[^)]+)\)/);
                  // Check for plain URL
                  const urlMatch = logoContent.match(/(https?:\/\/\S+\.(png|svg|jpg|jpeg|webp|gif)(\?[^\s]*)?)/i);
                  // Check for GitHub user-attachments URL (may not have extension)
                  const ghMatch = logoContent.match(/(https:\/\/github\.com\/user-attachments\/assets\/[^\s)]+)/);

                  logoUrl = mdMatch?.[1] || urlMatch?.[1] || ghMatch?.[1];
                  console.log('Logo content:', logoContent);
                  console.log('Logo URL found:', logoUrl);
                }
              }

              // Load existing projects
              const projectsPath = 'static/data/projects.json';
              const projects = JSON.parse(fs.readFileSync(projectsPath, 'utf-8'));

              if (projects.some(p => p.id === id)) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `‚ö†Ô∏è **Project already exists**\n\nA project with ID \`${id}\` is already in the catalog.`
                });
                return;
              }

              // Create branch
              const branchName = `submission/${id}-${issueNumber}`;
              const { data: ref } = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/main'
              });

              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: ref.object.sha
                });
              } catch (e) {
                if (e.status !== 422) throw e;
              }

              // Handle logo
              let logoPath = null;
              if (logoUrl) {
                try {
                  const response = await fetch(logoUrl);
                  if (response.ok) {
                    // Determine extension from URL or Content-Type
                    let ext = logoUrl.match(/\.(png|svg|jpg|jpeg|webp|gif)(\?|$)/i)?.[1];
                    if (!ext) {
                      const contentType = response.headers.get('content-type');
                      const typeMap = {
                        'image/png': 'png',
                        'image/svg+xml': 'svg',
                        'image/jpeg': 'jpg',
                        'image/webp': 'webp',
                        'image/gif': 'gif'
                      };
                      ext = typeMap[contentType] || 'png';
                    }

                    logoPath = `/logos/${id}.${ext.toLowerCase()}`;
                    project.logo = logoPath;

                    const buffer = await response.arrayBuffer();
                    await github.rest.repos.createOrUpdateFileContents({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      path: `static${logoPath}`,
                      message: `Add logo for ${project.name}`,
                      content: Buffer.from(buffer).toString('base64'),
                      branch: branchName
                    });
                  }
                } catch (e) {
                  console.log(`Failed to download logo: ${e.message}`);
                  delete project.logo;
                }
              }

              // Add project and update file
              projects.unshift(project);
              const projectsContent = JSON.stringify(projects, null, '\t') + '\n';

              const { data: projectsFile } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: projectsPath,
                ref: branchName
              });

              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: projectsPath,
                message: `Add ${project.name} to projects`,
                content: Buffer.from(projectsContent).toString('base64'),
                sha: projectsFile.sha,
                branch: branchName
              });

              // Create PR
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Add ${project.name} to PySimHub`,
                head: branchName,
                base: 'main',
                body: `## New Project: ${project.name}\n\nSubmitted by @${issueAuthor} in #${issueNumber}\n\n**Tagline:** ${project.tagline}\n**Tags:** ${project.tags.join(', ')}\n**Repository:** ${project.github}\n\n---\n\nü§ñ Auto-generated from issue #${issueNumber}`
              });

              // Comment on issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `üéâ **Thanks for your submission!**\n\nPR created: ${pr.html_url}\n\nA maintainer will review it shortly.`
              });

              // Add label and update title
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: ['pr-created']
              });

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                title: `[Submission] ${project.name}`
              });

              console.log(`Created PR #${pr.number} for ${project.name}`);

            } catch (error) {
              console.error('Error:', error);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `‚ùå **Error processing submission**\n\n\`\`\`\n${error.message}\n\`\`\`\n\nPlease check your JSON format and try again.`
              });
            }
