[
	{
		"name": "Archimedes",
		"tagline": "A Python framework for developing and deploying control systems",
		"description": "Archimedes is an open-source Python framework designed for deployment of control systems to hardware. To make this possible, it provides a comprehensive toolkit for modeling, simulation, optimization, and C code generation.  Archimedes builds on the powerful symbolic computation capabilities of [CasADi](https://web.casadi.org/docs/) with a modern interface designed to be familiar to users of NumPy, JAX, and PyTorch.",
		"tags": [
			"control",
			"digital-twin",
			"dynamic-systems",
			"engineering",
			"system-modeling",
			"transient"
		],
		"github": "https://github.com/PineTreeLabs/archimedes",
		"docs": "https://pinetreelabs.github.io/archimedes/",
		"pypi": "https://pypi.org/project/archimedes/",
		"example": "https://pinetreelabs.github.io/archimedes/getting-started.html",
		"id": "archimedes",
		"logo": "/logos/archimedes.png",
		"submittedBy": "jcallaham"
	},
	{
		"name": "EMerge",
		"tagline": "EMerge is a Python based finite element solver for electromagnetic waves",
		"description": "EMerge is a purely Python based finite element simulation library for electromagnetic waves. It offers similar features to software like CST, HFSS and Comsol Multiphysics. The entire process from geometry creation, meshing, boundary-condition setup, solving and post-processing can all be done in one and the same Python script.\n\nIt leverages fast C-optimized libraries like GMSH (OCC Geometry kernal), Scipy/Numpy for sparse data formatting, Numba for parallel accellerated assembly and SuperLU, UMFPACK, CuDSS for sparse linear solves.",
		"tags": [
			"engineering",
			"finite-element",
			"microwave",
			"physics",
			"rf",
			"radio-frequency",
			"electromagnetic"
		],
		"github": "https://github.com/FennisRobert/EMerge",
		"docs": "https://emerge-software.com/resources",
		"pypi": "https://pypi.org/project/emerge",
		"homepage": "https://www.emerge-software.com",
		"example": "https://github.com/FennisRobert/EMerge/tree/main/examples",
		"id": "emerge",
		"logo": "/logos/emerge.png",
		"submittedBy": "FennisRobert"
	},
	{
		"name": "Heavi",
		"tagline": "A python based circuit simulator for linear devices only (frequency domain)",
		"description": "Heavi is a purely python based circuit simulator for linear RF components. It computes S-parameters in the frequency domain. The library is entirely written in Python and accelerated with Numba. It implements the Modified Nodal Analysis (MNA) for circuit simulations as does software like Qucs and others. You can import Touchstone files and describe arbitrarily complex networks. \n\nHeavi currently does not have a working time domain solver.",
		"tags": [
			"engineering",
			"microwave",
			"radio-frequency",
			"rf",
			"circuit"
		],
		"github": "https://github.com/FennisRobert/heavi",
		"docs": "https://github.com/FennisRobert/heavi/wiki",
		"pypi": "https://pypi.org/project/heavi",
		"homepage": "https://www.emerge-software.com",
		"example": "https://github.com/FennisRobert/heavi/tree/main/examples",
		"id": "heavi",
		"submittedBy": "FennisRobert"
	},
	{
		"id": "scikit-rf",
		"name": "scikit-rf",
		"tagline": "Open Source Python package for RF/Microwave engineering",
		"description": "Created in 2009, scikit-rf (aka skrf) is a free, open-source Python library designed to make radio frequency (RF) engineering both reliable and accessible. scikit-rf is used worldwide in industry and research across sectors such as space, defense, telecommunications, and electronics. In a domain previously dominated by commercial software, scikit-rf, with over 2 million downloads and more than a hundred citations in scientific literature, has become a reference library for the analysis of radio frequency devices. In November 2024, the French Ministry of Higher Education and Research awarded the Open Science Prize for Open-Source Research Software to the scikit-rf project.",
		"tags": [
			"rf",
			"microwave",
			"visualization",
			"system-modeling",
			"engineering"
		],
		"logo": "/logos/scikit-rf.svg",
		"github": "https://github.com/scikit-rf/scikit-rf",
		"homepage": "https://scikit-rf.org/",
		"docs": "https://scikit-rf.readthedocs.io",
		"pypi": "https://pypi.org/project/scikit-rf/",
		"condaForge": "https://anaconda.org/conda-forge/scikit-rf",
		"example": "https://scikit-rf.readthedocs.io/en/latest/tutorials/Introduction.html"
	},
	{
		"id": "pathsim",
		"name": "PathSim",
		"tagline": "A dynamical system simulation framework in the block diagram paradigm",
		"description": "PathSim is a Python-native framework for modeling and simulating dynamical systems using block diagrams. It provides an intuitive API for building complex system models from interconnected blocks, supporting both continuous-time and discrete-time simulations. Designed for control systems, digital twins, and system-level modeling with a focus on ease of use and extensibility.",
		"tags": [
			"block-diagram",
			"digital-twin",
			"dynamic-systems",
			"control",
			"system-modeling",
			"transient"
		],
		"logo": "/logos/pathsim.png",
		"github": "https://github.com/pathsim/pathsim",
		"docs": "https://docs.pathsim.org",
		"pypi": "https://pypi.org/project/pathsim/",
		"condaForge": "https://anaconda.org/channels/conda-forge/packages/pathsim/overview",
		"example": "https://view.pathsim.org",
		"homepage": "https://pathsim.org"
	},
	{
		"id": "bdsim",
		"name": "bdsim",
		"tagline": "Block diagram simulation for robotics and control systems",
		"description": "bdsim is a Python framework for simulating block diagram models, particularly suited for robotics and control systems. It supports a wide range of block types including sources, sinks, transfer functions, and custom blocks. Part of the Robotics Toolbox ecosystem, it integrates seamlessly with robot models for system-level simulation and analysis.",
		"logo": "/logos/bdsim.svg",
		"tags": [
			"block-diagram",
			"robotics",
			"control",
			"dynamic-systems",
			"system-modeling",
			"transient"
		],
		"github": "https://github.com/petercorke/bdsim",
		"docs": "https://petercorke.github.io/bdsim/",
		"pypi": "https://pypi.org/project/bdsim/"
	},
	{
		"name": "PySD",
		"tagline": "Simulating System Dynamics Models in Python",
		"description": "This project is a simple library for running System Dynamics models in Python, with the purpose of improving integration of Big Data and Machine Learning into the SD workflow.\n\nPySD translates [Vensim](https://pysd.readthedocs.io/en/latest/structure/vensim_translation.html) or [XMILE](https://pysd.readthedocs.io/en/latest/structure/xmile_translation.html) model files into Python modules, and provides methods to modify, simulate, and observe those translated models. The translation is done through an intermediate [Abstract Syntax Tree representation](https://pysd.readthedocs.io/en/latest/structure/structure_index.html), which makes it possible to add builders in other languages in a simpler way",
		"tags": [
			"dynamic-systems",
			"system-modeling",
			"translation",
			"vensim",
			"xmile"
		],
		"github": "https://github.com/SDXorg/pysd",
		"docs": "https://pysd.readthedocs.io",
		"pypi": "https://pypi.org/project/pysd",
		"condaForge": "https://anaconda.org/conda-forge/pysd",
		"example": "https://pysd.readthedocs.io/en/latest/getting_started.html",
		"id": "pysd",
		"logo": "/logos/pysd.svg",
		"submittedBy": "enekomartinmartinez"
	},
	{
		"name": "Thermal Engineering Systems in Python: TESPy",
		"tagline": "A simulation framework in thermal engineering for systems like power plants, heat pumps or refrigeration machines",
		"description": "TESPy allows you to model component based thermodynamic cycles with an equation oriented solver. With a steady state simulation you can design a process and run  offdesign calculations of your plant using underlying characteristics for each of the plant's components. The package includes basic components, such as turbines, pumps, compressors, heat exchangers, pipes, mixers and splitters as well as advanced components (derivatives of heat exchangers, drum). Due to its flexible design you can implement your own components easily, inject custom constraints or switch to different fluid property databases.",
		"tags": [
			"engineering",
			"physics",
			"system-modeling",
			"thermodynamics",
			"cycle simulation",
			"refrigeration",
			"heating",
			"powerplant"
		],
		"github": "https://github.com/oemof/tespy",
		"docs": "https://tespy.readthedocs.io/",
		"pypi": "https://pypi.org/project/tespy/",
		"condaForge": "https://anaconda.org/channels/conda-forge/packages/tespy/overview",
		"example": "https://tespy.readthedocs.io/en/main/basic_tutorials.html",
		"id": "thermal-engineering-systems-in-python-tespy",
		"logo": "/logos/thermal-engineering-systems-in-python-tespy.svg",
		"submittedBy": "fwitte"
	},
	{
		"name": "Pymunk",
		"tagline": "Pymunk is a easy-to-use pythonic 2d physics library that can be used whenever you need 2d rigid body physics from Python",
		"description": "Pymunk is an easy-to-use pythonic 2D physics library that can be used whenever you need 2D rigid body physics from Python. Perfect when you need 2D physics in your game, demo or simulation! It is built on top of Munk2D, a fork of the very capable 2D physics library [Chipmunk2D](http://chipmunk-physics.net/).\n\nThe first version was released in 2007 and Pymunk is still actively developed and maintained today, more than 15 years of active development!\n\nPymunk has been used with success in many projects, big and small. For example: 3 Pyweek game competition winners, dozens of published scientific papers and even in a self-driving car simulation! See the Showcases section on the Pymunk webpage for some examples.",
		"tags": [
			"physics"
		],
		"github": "https://github.com/viblo/pymunk",
		"docs": "https://www.pymunk.org",
		"pypi": "https://pypi.org/project/pymunk/",
		"condaForge": "https://anaconda.org/conda-forge/pymunk",
		"homepage": "https://www.pymunk.org",
		"id": "pymunk",
		"logo": "/logos/pymunk.png",
		"submittedBy": "viblo"
	},
	{
		"name": "Mesa",
		"tagline": "Mesa is an open-source Python library for agent-based modeling.",
		"description": "Mesa is an open-source Python library for agent-based modeling, ideal for simulating complex systems and exploring emergent behaviors.",
		"tags": [
			"cycle simulation",
			"digital-twin",
			"dynamic-systems",
			"system-modeling"
		],
		"github": "https://github.com/mesa/mesa",
		"docs": "https://mesa.readthedocs.io/latest/",
		"pypi": "https://pypi.org/project/Mesa/",
		"example": "https://mesa.readthedocs.io/stable/examples.html",
		"id": "mesa",
		"submittedBy": "jackiekazil"
	},
	{
		"name": "Brian2",
		"tagline": "A simulator for spiking neural networks.",
		"description": "The “Brian” simulator is a simulation software for biological spiking neural networks. Neuroscientists write their model in a high-level language (Python) with a simple syntax based on mathematical equations and physical units. Behind the scenes, Brian converts users’ high-level code into efficient, low-level code to run the simulation. The software therefore allows users to easily write models without sacrificing computational efficiency. This unique mix of user-friendliness and efficiency has made it a standard tool for computational neuroscientists worldwide. Brian is used for research and teaching, and is embedded in an ecosystem of supplementary software packages. These packages include convenience tools for plotting, model import/export, and model fitting, computational backends adding support for hardware platforms such as GPUs, and domain-specific frameworks, e.g. for simulating optogenetic experiments.\n\nBrian has been in continual development since 2007, with a major rewrite as \"Brian2\" in 2014.",
		"tags": [
			"system-modeling",
			"network",
			"spiking neural network",
			"snn",
			"neuroscience",
			"computational neuroscience"
		],
		"github": "https://github.com/brian-team/brian2",
		"docs": "https://brian2.readthedocs.org",
		"pypi": "https://pypi.org/project/Brian2/",
		"condaForge": "https://anaconda.org/channels/conda-forge/packages/brian2/overview",
		"homepage": "https://briansimulator.org",
		"example": "https://briansimulator.org/getting-started/",
		"id": "brian2",
		"logo": "/logos/brian2.png",
		"submittedBy": "mstimberg"
	},
	{
		"name": "scikit-fem",
		"tagline": "Simple finite element assemblers",
		"description": "The purpose of scikit-fem is to simplify the creation of finite element matrices, i.e., the finite element assembly. It can be used as a component to create finite element solvers for a wide variety of partial differential equations. It supports the most popular 1D, 2D and 3D mesh types and elements, and in addition implements some of the more exotic elements, e.g., for $H(div)$ and $H(curl)$ conforming saddle point problems and $H^2$ conforming elliptic problems.",
		"tags": [
			"finite-element"
		],
		"github": "https://github.com/kinnala/scikit-fem",
		"docs": "https://scikit-fem.readthedocs.io",
		"pypi": "https://pypi.org/project/scikit-fem/",
		"condaForge": "https://anaconda.org/channels/conda-forge/packages/scikit-fem/overview",
		"id": "scikit-fem",
		"logo": "/logos/scikit-fem.png",
		"submittedBy": "kinnala"
	},
	{
		"name": "AutoEmulate",
		"tagline": "Emulate simulations easily",
		"description": "AutoEmulate is a Python library that makes it easy to create accurate and efficient emulators for complex simulations. Under the hood, the package runs a complete machine learning pipeline to compare and optimise a wide range of models, and provides functions for downstream tasks like prediction, sensitivity analysis and calibration.",
		"tags": [
			"digital-twin",
			"engineering",
			"physics",
			"emulation",
			"sensitivity analysis",
			"calibration",
			"uncertainty quantification"
		],
		"github": "https://github.com/alan-turing-institute/autoemulate",
		"docs": "https://alan-turing-institute.github.io/autoemulate/",
		"pypi": "https://pypi.org/project/autoemulate/",
		"homepage": "https://www.autoemulate.com",
		"example": "https://alan-turing-institute.github.io/autoemulate/tutorials/index.html",
		"id": "autoemulate",
		"logo": "https://raw.githubusercontent.com/alan-turing-institute/autoemulate/refs/heads/main/misc/AE_logo_final.png",
		"submittedBy": "radka-j"
	}
]
